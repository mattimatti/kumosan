//@version=5
strategy("BBWP Strategy", overlay=true, format=format.percent, precision=2, max_bars_back=1000,
     initial_capital=1000, default_qty_type=strategy.percent_of_equity, default_qty_value=10)

// ==== Parametri ====
length        = input.int(10,  "BBWP Length", minval=5)
lookback      = input.int(50, "Percentile Lookback", minval=50)
lowTh         = input.float(20.0,  "Low Threshold (%)")       
trigger       = input.float(20.0, "Trigger Spread (%)")
topTrigger    = input.float(85.0, "Trigger Spread (%)")
emaLen        = input.int(50,  "EMA Length", minval=1)
atrLen        = input.int(14, "ATR Length", minval=1)
emaShortLen   = input.int(50, "EMA Short Length (HTF)", minval=1)
emaLongLen    = input.int(200,"EMA Long Length (HTF)", minval=1)
multiplier = input.int(10, "Moltiplicatore TF")
atrMaxTh      = input.float(3.0, "ATR% massimo", step=0.1)
atrCrossTh    = input.float(0.2, "ATR% minimo", step=0.1)

// ==== Parametri gestione trade ====
atrMultSL     = input.float(5, "Stop Loss ATR multiplo", step=0.1)
atrMultTP     = input.float(500.0, "Take Profit ATR multiplo", step=0.1)



// Funzione: restituisce timeframe moltiplicato come stringa
f_tfMult(_mult) =>
    string tfStr = ""
    if timeframe.isintraday
        // intraday → minuti
        baseMinutes = timeframe.multiplier
        newMinutes  = baseMinutes * _mult
        tfStr := str.tostring(newMinutes)      // es: "15" * 2 → "30"
    else if timeframe.isdaily
        baseDays = timeframe.multiplier
        newDays  = baseDays * _mult
        tfStr := str.tostring(newDays) + "D"  // es: "1D" * 2 → "2D"
    else if timeframe.isweekly
        baseWeeks = timeframe.multiplier
        newWeeks  = baseWeeks * _mult
        tfStr := str.tostring(newWeeks) + "W" // es: "1W" * 2 → "2W"
    else if timeframe.ismonthly
        baseMonths = timeframe.multiplier
        newMonths  = baseMonths * _mult
        tfStr := str.tostring(newMonths) + "M" // es: "1M" * 2 → "2M"
    else
        tfStr := timeframe.period              // fallback
    tfStr



tfFilter   = f_tfMult(multiplier)


// ==== Funzione BBWP percentile ====
f_bbwp(src, _len, _lb) =>
    [basis, upper, lower] = ta.bb(src, _len, 2.0)
    rng   = upper - lower
    denom = math.max(basis, 1e-10)
    w     = (rng / denom) * 100.0
    maxLag = math.min(_lb - 1, bar_index)
    float count = 0.0
    float valid = 0.0
    for i = 0 to maxLag
        if not na(w[i])
            valid += 1.0
            count += (w >= w[i] ? 1.0 : 0.0)
    valid > 0 ? (count / valid) * 100.0 : na

// ==== Calcolo BBWP ====
bbwp = f_bbwp(close, length, lookback)



// ==== ATR ====
atr = ta.atr(atrLen)
atrPct = (atr / close) * 100



// Bande di Bollinger


// Parametri
bbLen  = input.int(20, "Lunghezza BB")
bbMult = input.float(2.0, "Deviazione Std")

[basis, upper, lower] = ta.bb(close, bbLen, bbMult)


midTop = (basis + upper) / 2
midBottom = (basis + lower) / 2
outsideBB = close > upper
isBelowMidBB = close < basis
isAboveLowBB = open > lower and open < basis
isBelowTop = close < high and close > basis
isBelowMidTop = close < midTop


// the distance
bbWidthPct = (upper - lower) / close * 100


// Calcolo RSI
rsi = ta.rsi(close, 14)
// Condizioni boolean
isOverbought = rsi > 60
isOversold   = rsi < 30
isNeutral    = rsi >= 30 and rsi <= 60


// Verifica direzione
isRSIRising  = ta.rising(rsi, 1)   // RSI in salita
isRSIFalling = ta.falling(rsi, 2)  // RSI in discesa


// === Parametri Divergenza ===
lookbackLeft  = input.int(5, "Pivot Left")
lookbackRight = input.int(5, "Pivot Right")
rangeUpper    = input.int(60, "Range Upper Bars")
rangeLower    = input.int(5,  "Range Lower Bars")

// Funzione helper per controllare che due pivot siano "vicini"
_inRange(cond) =>
    bars = ta.barssince(cond)
    rangeLower <= bars and bars <= rangeUpper

// === Pivot RSI ===
plFound = not na(ta.pivotlow(rsi, lookbackLeft, lookbackRight))   // RSI pivot low
phFound = not na(ta.pivothigh(rsi, lookbackLeft, lookbackRight))  // RSI pivot high

rsiLBR  = rsi[lookbackRight]

// === Bullish Divergence ===
// RSI: higher low
rsiHL   = rsiLBR > ta.valuewhen(plFound, rsiLBR, 1) and _inRange(plFound[1])
// Prezzo: lower low
lowLBR  = low[lookbackRight]
priceLL = lowLBR < ta.valuewhen(plFound, lowLBR, 1)
bullCond = priceLL and rsiHL and plFound

// === Bearish Divergence ===
// RSI: lower high
rsiLH   = rsiLBR < ta.valuewhen(phFound, rsiLBR, 1) and _inRange(phFound[1])
// Prezzo: higher high
highLBR = high[lookbackRight]
priceHH = highLBR > ta.valuewhen(phFound, highLBR, 1)
//bearCond = priceHH and rsiLH and phFound


maLength  = input.int(9, "RSI MA Length")
maType = 'EMA'
rsiMA = switch maType
    "SMA" => ta.sma(rsi, maLength)
    "EMA" => ta.ema(rsi, maLength)
    "RMA" => ta.rma(rsi, maLength)
    "WMA" => ta.wma(rsi, maLength)

bearCond = ta.crossunder(rsi, rsiMA)


rsiLongCond = rsi < rsiMA




// Parametri MACD
fastLen   = input.int(12, "MACD Fast Length")
slowLen   = input.int(26, "MACD Slow Length")
signalLen = input.int(9,  "Signal Length")

// Calcolo MACD
[macdLine, signalLine, hist] = ta.macd(close, fastLen, slowLen, signalLen)

minDiff = input.float(0.01, "Soglia minima distanza MACD-Signal")

diff = math.abs(macdLine - signalLine)

// Condizione incrocio ribassista
bullCross = ta.crossover(macdLine, signalLine)


bearCross = ta.crossunder(macdLine, signalLine)  //and (math.abs(macdLine - signalLine) > 0.005) // and (math.abs(hist) > 0.01)


// Slope del MACD
slopeMac = macdLine - macdLine[1]

// Condizioni trend
trendBull = slopeMac > 0 and macdLine > 0
trendBear = slopeMac < 0 and macdLine < 0
trendWeak = not trendBull and not trendBear   // fase di indecisione/sideways





// ==== Condizioni operative BBWP ====

smoothLen = input.int(3, "Smoothing length", minval=1)
bbwpSmooth = ta.ema(bbwp, smoothLen)
//isCompression = not na(bbwp) and bbwp <= lowTh

bbWidth = (upper - lower) / basis * 100


bool isSideways = trendWeak   // sotto 5% ampiezza = laterale
bool isCompression =  bbWidth > 3  and bbWidth < 5  // sotto 5% ampiezza = laterale

// Controllo anche le 2 barre precedenti
recentCompression = isCompression or isCompression[1] or isCompression[2] or isCompression[3] or isCompression[4] or isCompression[5]
volRising = volume > volume[1]       // bool: volume in aumento?
atrRising = atr > atr[1]             // bool: sta salendo?

isBreakoutLarge = bullCross and volRising and atrRising and rsi <=60

//isCompression = not na(bbwp) and bbwp <= lowTh



minBBWP  = ta.lowest(bbwp, lookback/2)
maxBBWP     = ta.highest(bbwp, lookback/2)             // massimo BBWP nelle ultime N barre
triggerDyn  = maxBBWP * 0.01                        // 10% del massimo

trigger200 = ta.ema(trigger, 50)
trigger :=  20 // trigger200 + triggerDyn //triggerDyn + trigger200


lowTh := minBBWP  + trigger200




bbwp_ma10 = ta.sma(bbwp, 40)
//plot(bbwp_ma10, title="BBWP SMA10", color=color.orange, linewidth=2)


isChannelDown = trendBear
isChannelUp = trendBull


// ======= PRE BREAK =========



bool isPreBreak = false 
//isPreBreak := ta.crossover(bbwpSmooth, bbwp)
//isPreBreak    :=  false //ta.crossover(bbwpSmooth, lowTh) or (bbwpSmooth > lowTh and bbwpSmooth < trigger and ta.rising(bbwpSmooth, 2))


isSidewaysBull = isSideways and bullCross


isPreBreak := isSidewaysBull

// ======= BREAKOUT =========




isBreakout = false

// LOW Breakup 
isBreakoutLow = (ta.crossover(bbwp, trigger) and bbwp < 40) and isBelowMidTop and isAboveLowBB and not isChannelDown and (trigger < 20 )


isBreakoutLow := isBreakoutLow 

// TOP Breakup
isBreakoutHigh =  false // isBreakout or (ta.crossunder(bbwp, bbwpSmooth) and bbwp > 85) and isBelowMidTop

// TOP Breakup
//isBreakoutHigh :=  isBreakout or (ta.crossover(bbwp, 85)) and isBelowMidTop


isBreakout := (isBreakoutLow or isBreakoutHigh)











//smoothCross = ta.crossunder(bbwp, bbwpSmooth) and bbwp > 80





// ==== EMA & Trend ====
ema50   = ta.ema(close, emaLen)
ema200  = ta.ema(close, 200)
ema9    = ta.ema(close, 9)
ema18   = ta.ema(close, 18)
em34    = ta.ema(close, 34)
ema144   = ta.ema(close, 144)


emaSlope = ema50 - ema50[3]
emaApproachingUp = emaSlope > 0


trendDown  = em34 < ema144



// ==== EMA su TF superiore ====
ema50_htf  = request.security(syminfo.tickerid, tfFilter, ta.ema(close, emaShortLen))
ema200_htf = request.security(syminfo.tickerid, tfFilter, ta.ema(close, emaLongLen))

trendUp    = ema50 > ema200
//trendDown  = ema50_htf < ema200_htf

// ==== Spread EMA9-EMA18 ====
emaDistance = ((ema9 - ema18) / math.max(ema18, 1e-10)) * 100
spreadPos   = emaDistance > 0







dropPerc = ((bbwp - bbwp[1]) / bbwp[1]) * 100
isDrop    = dropPerc < -30   // ad es. crollo >30% in una barra
isVshape = ta.falling(bbwp, 1) and ta.rising(bbwp, 1)



isValidMacdBull = bullCross and rsi > 30





longCondition = false
// ==== ENTRY LONG fedele allo screener ====
//longCondition := (isPreBreak or isBreakout) and trendUp and emaApproachingUp and spreadPos and (atrPct > atrCrossTh and atrPct < atrMaxTh)
longCondition := (isPreBreak or isBreakout or isBreakoutLarge) //and trendUp and emaApproachingUp //and spreadPos and (atrPct > atrCrossTh and atrPct < atrMaxTh)
//longCondition := longCondition or smoothCross

longCondition := longCondition and not isRSIFalling and not rsiLongCond and trendUp









plotshape(isPreBreak, title="Segnale", style=shape.triangleup, color=color.green, size=size.small)
plotshape(isBreakoutHigh, title="Segnale", style=shape.triangleup, color=color.yellow, size=size.small)
plotshape(isBreakoutLow, title="Segnale", style=shape.triangleup, color=color.red, size=size.small)




//plotshape(bearCross, title="bearCross", style=shape.triangledown, color=color.red, size=size.large)









// ======================================
// ==== Trading Session Filter Plugin ===
// ======================================

// Giorni abilitati (lunedì=1 … domenica=7)
allowMon = input.bool(true,  "Trade Monday",  group="Session Filter")
allowTue = input.bool(true,  "Trade Tuesday", group="Session Filter")
allowWed = input.bool(true,  "Trade Wednesday", group="Session Filter")
allowThu = input.bool(true,  "Trade Thursday", group="Session Filter")
allowFri = input.bool(true,  "Trade Friday",  group="Session Filter")
allowSat = input.bool(false, "Trade Saturday", group="Session Filter")
allowSun = input.bool(false, "Trade Sunday",   group="Session Filter")

// Orari (24h, timezone del grafico)
startHour = input.int(9,  "Start Hour",  minval=0, maxval=23, group="Session Filter")
endHour   = input.int(17, "End Hour",    minval=0, maxval=23, group="Session Filter")

// Controlli
currentDay  = dayofweek(time)
currentHour = hour(time)

dayAllowed = (allowMon and currentDay==dayofweek.monday) or
             (allowTue and currentDay==dayofweek.tuesday) or
             (allowWed and currentDay==dayofweek.wednesday) or
             (allowThu and currentDay==dayofweek.thursday) or
             (allowFri and currentDay==dayofweek.friday) or
             (allowSat and currentDay==dayofweek.saturday) or
             (allowSun and currentDay==dayofweek.sunday)

hourAllowed = (currentHour >= startHour) and (currentHour < endHour)

// Flag finale
tradeSessionOk = dayAllowed and (timeframe.isintraday? hourAllowed: true)
tradeSessionOk := true


//colorTradingSession = input.color(color.new(color.purple, 80), "Colore barra Pre-Breakout")
//bgcolor(tradeSessionOk ? colorTradingSession : na, title="Pre-Breakout Stripe")



isRising   = ta.rising(bbwp, 1)   // true se bbwp > bbwp[1]
isFalling  = ta.falling(bbwp, 1)  // true se bbwp < bbwp[1]


// Exit Conditions


// Linea a metà tra basis e top

// Condizione booleana: prezzo rientra sotto la banda superiore
ref = midTop
reentryTop = false
reentryTop := close <= ref and close[1] > ref[1]
reentryTop := reentryTop and bbwp > 90





slope = bbwp - bbwp[1]                  // differenza 1 barra
slopePerc = (bbwp - bbwp[1]) / bbwp[1] * 100
isVerticalUp = slopePerc > 50           // soglia: crescita >50% in 1 barra





isInverting  = outsideBB and isVerticalUp and bbwp > 85

isSlippage = false


//stopLevel   = close - atr * atrMultSL
//targetLevel = close + atr * atrMultTP

//if (tradeSessionOk and isBreakoutLarge and strategy.position_size == 0 )
//    strategy.entry("Breakout", strategy.long)


alertcondition(tradeSessionOk and longCondition, "Long", "Buy signal")


if (tradeSessionOk and longCondition and strategy.position_size == 0 )
    title = isBreakoutLarge ? "BreakOut" : ""
    strategy.entry("Long", strategy.long,alert_message = title)
    
// Condizione: signal in discesa
bool signalDown = signalLine < signalLine[1]

// ==== EXIT fedele allo screener ====
if (tradeSessionOk and strategy.position_size > 0)
    entryPrice = strategy.position_avg_price
    //if trendUp
       // targetLevel = close + (atr * atrMultTP)
        //strategy.exit("TP/SL", from_entry="Long", profit = targetLevel)

    if trendDown
        stopLevel  = strategy.position_avg_price * 0.95     // -10%
        targetLevel  = close + atr * atrMultTP
        //strategy.exit("TP/SL", from_entry="Long", stop=stopLevel)
    //if reentryTop
    //    strategy.close("Long", comment="Rientra in Bollinger")
    
    if bearCross and rsi > 60
        strategy.close("Long", comment="Exit bear macd")
    if bearCross and isRSIFalling and not isCompression
        strategy.close("Long", comment="Exit bear macd") 
   //if isInverting
    //    strategy.close("Long", comment="Inverting")
    if isSlippage
        strategy.close("Long", comment="Slippage")
    //if isInverting
     //   strategy.close("Long", comment="Inverting ")
    //if isSideways
     //  strategy.close("Long", comment="Sideways ")
    if bearCond and signalLine > macdLine and not isCompression and not trendUp
        strategy.close("Long", comment="Bear RSI")

    //if close < lower
    //    strategy.close("Long", comment="OUT")

    //if isCompression
    //    strategy.close("Long", comment="Compression")
    //if isCompressing
     //   strategy.close("Long", comment="Stallo")











// --- Tracking entry ---
var float entryPrice = na
var bool inTrade = false

// Quando entriamo in posizione: salva entryPrice
if (strategy.position_size > 0 and not inTrade)
    entryPrice := strategy.position_avg_price
    inTrade := true

// Quando usciamo: calcola profit e mostra label
if (strategy.position_size == 0 and inTrade)
    profitPerc = (close - entryPrice) / entryPrice * 100
    if profitPerc < 0
        label.new(bar_index, close, text="Profit: " +  str.tostring(profitPerc, "#.##") + "%", style=label.style_label_down, color=(profitPerc>=0?color.green:color.red), textcolor=color.white)
    entryPrice := na
    inTrade := false






// ==== Debug plots ====
//plot(bbWidthPct, "bbWidthPct", color=color.green, linewidth = 5)
//plot(bbwpSmooth, "BBWP %", color=color.black )
//plot(bbwp, "BBWP %", color=color.blue)
//plot(atrPct, "ATR %", color=color.purple)
//hline(50, "mid", color=color.white)
//plot(lowTh, "trigger", color=color.red)


// isRSIFalling
// isChannelDown
// trendBear
// trendDown
//bgcolor(trendUp ? color.new(color.green, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(isSideways ? color.new(color.blue, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(isChannelUp ? color.new(color.green, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(recentCompression ? color.new(color.yellow, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(isBreakoutLarge ? color.new(color.red, 80) : na, title="Pre-Breakout Stripe")





prd = input.int(defval = 10, title = 'Pivot Period', minval = 4, maxval = 30, group = 'Settings 🔨', tooltip = 'Used while calculating Pivot Points, checks left&right bars')
ppsrc = input.string(defval = 'High/Low', title = 'Source', options = ['High/Low', 'Close/Open'], group = 'Settings 🔨', tooltip = 'Source for Pivot Points')
ChannelW = input.int(defval = 5, title = 'Maximum Channel Width %', minval = 1, maxval = 8, group = 'Settings 🔨', tooltip = 'Calculated using Highest/Lowest levels in 300 bars')
minstrength = input.int(defval = 1, title = 'Minimum Strength', minval = 1, group = 'Settings 🔨', tooltip = 'Channel must contain at least 2 Pivot Points')
maxnumsr = input.int(defval = 6, title = 'Maximum Number of S/R', minval = 1, maxval = 10, group = 'Settings 🔨', tooltip = 'Maximum number of Support/Resistance Channels to Show') - 1
loopback = input.int(defval = 290, title = 'Loopback Period', minval = 100, maxval = 400, group = 'Settings 🔨', tooltip = 'While calculating S/R levels it checks Pivots in Loopback Period')
res_col = input.color(defval = color.new(color.red, 75), title = 'Resistance Color', group = 'Colors 🟡🟢🟣')
sup_col = input.color(defval = color.new(color.lime, 75), title = 'Support Color', group = 'Colors 🟡🟢🟣')
inch_col = input.color(defval = color.new(color.gray, 75), title = 'Color When Price in Channel', group = 'Colors 🟡🟢🟣')
showpp = input.bool(defval = false, title = 'Show Pivot Points', group = 'Extras ⏶⏷')
showsrbroken = input.bool(defval = false, title = 'Show Broken Support/Resistance', group = 'Extras ⏶⏷')
showthema1en = input.bool(defval = false, title = 'MA 1', inline = 'ma1')
showthema1len = input.int(defval = 50, title = '', inline = 'ma1')
showthema1type = input.string(defval = 'SMA', title = '', options = ['SMA', 'EMA'], inline = 'ma1')
showthema2en = input.bool(defval = false, title = 'MA 2', inline = 'ma2')
showthema2len = input.int(defval = 200, title = '', inline = 'ma2')
showthema2type = input.string(defval = 'SMA', title = '', options = ['SMA', 'EMA'], inline = 'ma2')

ma1 = showthema1en ? showthema1type == 'SMA' ? ta.sma(close, showthema1len) : ta.ema(close, showthema1len) : na
ma2 = showthema2en ? showthema2type == 'SMA' ? ta.sma(close, showthema2len) : ta.ema(close, showthema2len) : na

plot(ma1, color = not na(ma1) ? color.blue : na)
plot(ma2, color = not na(ma2) ? color.red : na)

// get Pivot High/low
float src1 = ppsrc == 'High/Low' ? high : math.max(close, open)
float src2 = ppsrc == 'High/Low' ? low : math.min(close, open)
float ph = ta.pivothigh(src1, prd, prd)
float pl = ta.pivotlow(src2, prd, prd)

// draw Pivot points
plotshape(bool(ph) and showpp, text = 'H', style = shape.labeldown, color = na, textcolor = color.new(color.red, 0), location = location.abovebar, offset = -prd)
plotshape(bool(pl) and showpp, text = 'L', style = shape.labelup, color = na, textcolor = color.new(color.lime, 0), location = location.belowbar, offset = -prd)

//calculate maximum S/R channel width
prdhighest = ta.highest(300)
prdlowest = ta.lowest(300)
cwidth = (prdhighest - prdlowest) * ChannelW / 100

// get/keep Pivot levels
var pivotvals = array.new_float(0)
var pivotlocs = array.new_float(0)
if bool(ph) or bool(pl)
    array.unshift(pivotvals, bool(ph) ? ph : pl)
    array.unshift(pivotlocs, bar_index)
    for x = array.size(pivotvals) - 1 to 0 by 1
        if bar_index - array.get(pivotlocs, x) > loopback // remove old pivot points
            array.pop(pivotvals)
            array.pop(pivotlocs)
            continue
        break

//find/create SR channel of a pivot point
get_sr_vals(ind) =>
    float lo = array.get(pivotvals, ind)
    float hi = lo
    int numpp = 0
    for y = 0 to array.size(pivotvals) - 1 by 1
        float cpp = array.get(pivotvals, y)
        float wdth = cpp <= hi ? hi - cpp : cpp - lo
        if wdth <= cwidth // fits the max channel width?
            if cpp <= hi
                lo := math.min(lo, cpp)
                lo
            else
                hi := math.max(hi, cpp)
                hi

            numpp := numpp + 20 // each pivot point added as 20
            numpp
    [hi, lo, numpp]

// keep old SR channels and calculate/sort new channels if we met new pivot point
var suportresistance = array.new_float(20, 0) // min/max levels
changeit(x, y) =>
    tmp = array.get(suportresistance, y * 2)
    array.set(suportresistance, y * 2, array.get(suportresistance, x * 2))
    array.set(suportresistance, x * 2, tmp)
    tmp := array.get(suportresistance, y * 2 + 1)
    array.set(suportresistance, y * 2 + 1, array.get(suportresistance, x * 2 + 1))
    array.set(suportresistance, x * 2 + 1, tmp)

if bool(ph) or bool(pl)
    supres = array.new_float(0) // number of pivot, strength, min/max levels
    stren = array.new_float(10, 0)
    // get levels and strengs
    for x = 0 to array.size(pivotvals) - 1 by 1
        [hi, lo, strength] = get_sr_vals(x)
        array.push(supres, strength)
        array.push(supres, hi)
        array.push(supres, lo)

    // add each HL to strengh
    for x = 0 to array.size(pivotvals) - 1 by 1
        h = array.get(supres, x * 3 + 1)
        l = array.get(supres, x * 3 + 2)
        s = 0
        for y = 0 to loopback by 1
            if high[y] <= h and high[y] >= l or low[y] <= h and low[y] >= l
                s := s + 1
                s
        array.set(supres, x * 3, array.get(supres, x * 3) + s)

    //reset SR levels
    array.fill(suportresistance, 0)
    // get strongest SRs
    src = 0
    for x = 0 to array.size(pivotvals) - 1 by 1
        stv = -1. // value
        stl = -1 // location
        for y = 0 to array.size(pivotvals) - 1 by 1
            if array.get(supres, y * 3) > stv and array.get(supres, y * 3) >= minstrength * 20
                stv := array.get(supres, y * 3)
                stl := y
                stl
        if stl >= 0
            //get sr level
            hh = array.get(supres, stl * 3 + 1)
            ll = array.get(supres, stl * 3 + 2)
            array.set(suportresistance, src * 2, hh)
            array.set(suportresistance, src * 2 + 1, ll)
            array.set(stren, src, array.get(supres, stl * 3))

            // make included pivot points' strength zero 
            for y = 0 to array.size(pivotvals) - 1 by 1
                if array.get(supres, y * 3 + 1) <= hh and array.get(supres, y * 3 + 1) >= ll or array.get(supres, y * 3 + 2) <= hh and array.get(supres, y * 3 + 2) >= ll
                    array.set(supres, y * 3, -1)

            src := src + 1
            if src >= 10
                break

    for x = 0 to 8 by 1
        for y = x + 1 to 9 by 1
            if array.get(stren, y) > array.get(stren, x)
                tmp = array.get(stren, y)
                array.set(stren, y, array.get(stren, x))
                changeit(x, y)


get_level(ind) =>
    float ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind)
            ret
    ret

get_color(ind) =>
    color ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind) > close and array.get(suportresistance, ind + 1) > close ? res_col : array.get(suportresistance, ind) < close and array.get(suportresistance, ind + 1) < close ? sup_col : inch_col
            ret
    ret

var srchannels = array.new_box(10)
for x = 0 to math.min(9, maxnumsr) by 1
    box.delete(array.get(srchannels, x))
    srcol = get_color(x * 2)
    if not na(srcol)
        array.set(srchannels, x, box.new(left = bar_index, top = get_level(x * 2), right = bar_index + 1, bottom = get_level(x * 2 + 1), border_color = srcol, border_width = 1, extend = extend.both, bgcolor = srcol))

resistancebroken = false
supportbroken = false

// check if it's not in a channel
not_in_a_channel = true
for x = 0 to math.min(9, maxnumsr) by 1
    if close <= array.get(suportresistance, x * 2) and close >= array.get(suportresistance, x * 2 + 1)
        not_in_a_channel := false
        not_in_a_channel

// if price is not in a channel then check broken ones
if not_in_a_channel
    for x = 0 to math.min(9, maxnumsr) by 1
        if close[1] <= array.get(suportresistance, x * 2) and close > array.get(suportresistance, x * 2)
            resistancebroken := true
            resistancebroken
        if close[1] >= array.get(suportresistance, x * 2 + 1) and close < array.get(suportresistance, x * 2 + 1)
            supportbroken := true
            supportbroken

alertcondition(resistancebroken, title = 'Resistance Broken', message = 'Resistance Broken')

alertcondition(supportbroken, title = 'Support Broken', message = 'Support Broken')

plotshape(showsrbroken and resistancebroken, style = shape.triangleup, location = location.belowbar, color = color.new(color.lime, 0), size = size.tiny)
plotshape(showsrbroken and supportbroken, style = shape.triangledown, location = location.abovebar, color = color.new(color.red, 0), size = size.tiny)






// === Parametri tolleranza
tolleranzaPerc = input.float(0.5, "Tolleranza (%)", minval=0.1) / 100

// === Ciclo su tutte le S/R trovate
i = 0

float res = array.get(suportresistance, i*2)     // livello alto (resistenza)
float sup = array.get(suportresistance, i*2 + 1) // livello basso (supporto)

// --- Condizioni Resistenza ---
bool approachingRes = not na(res) and close < res and res - close <= res * tolleranzaPerc
bool bouncedRes     = not na(res) and close[1] <= res and close < res and high[1] >= res
bool brokenRes      = not na(res) and close[1] < res and close > res

//if approachingRes
//    label.new(bar_index, close, "Approcciando R", color=color.orange, textcolor=color.white, style=label.style_label_down)
//if bouncedRes
//    label.new(bar_index, close, "Rimbalzato R", color=color.red, textcolor=color.white, style=label.style_label_down)
//if brokenRes
//    label.new(bar_index, close, "Bucato R", color=color.green, textcolor=color.white, style=label.style_label_down)


bgcolor(approachingRes ? color.new(color.red, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(bouncedRes ? color.new(color.orange, 80) : na, title="Pre-Breakout Stripe")



// --- Condizioni Supporto ---
bool approachingSup = not na(sup) and close > sup and close - sup <= sup * tolleranzaPerc
bool bouncedSup     = not na(sup) and close[1] >= sup and close > sup and low[1] <= sup
bool brokenSup      = not na(sup) and close[1] > sup and close < sup

//if approachingSup
    //label.new(bar_index, close, "Approcciando S", color=color.orange, textcolor=color.black, style=label.style_label_up)
//if bouncedSup
    //label.new(bar_index, close, "Rimbalzato S", color=color.lime, textcolor=color.black, style=label.style_label_up)
//if brokenSup
//    label.new(bar_index, close, "Bucato S", color=color.red, textcolor=color.white, style=label.style_label_up)


bgcolor(approachingSup ? color.new(color.green, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(bouncedSup ? color.new(color.orange, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(brokenSup ? color.new(color.green, 80) : na, title="Pre-Breakout Stripe")

//bgcolor(isSideways ? color.new(color.blue, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(isChannelUp ? color.new(color.green, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(recentCompression ? color.new(color.yellow, 80) : na, title="Pre-Breakout Stripe")
//bgcolor(isBreakoutLarge ? color.new(color.red, 80) : na, title="Pre-Breakout Stripe")



// === Parametri ===
symTotal2 = input.string("CRYPTOCAP:TOTAL2", "Symbol TOTAL2")
lookbackk  = input.int(200, "Periodo base (barre)")

// === Prezzo normalizzato (base = 100 al lookback) ===
crypto_base = close[lookback]
crypto_perf = (close / crypto_base) * 100

total2_close = request.security(symTotal2, timeframe.period, close)
total2_base  = total2_close[lookbackk]
total2_perf  = (total2_close / total2_base) * 100

// === Condizione booleana ===
bool sovraperforma = crypto_perf > total2_perf


bgcolor(sovraperforma ? color.new(color.green, 80) : na, title="Pre-Breakout Stripe")
