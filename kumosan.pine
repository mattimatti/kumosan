//@version=5
indicator("KumoSAN", overlay=true)

// --- Ichimoku lengths
convLen=input.int(9,"Tenkan",minval=1)
baseLen=input.int(26,"Kijun",minval=1)
spanBLen=input.int(52,"Senkou B",minval=1)

// --- Visual SHORT
showShort=input.bool(false,"Attiva sezione SHORT")
showShortMarker=input.bool(false,"Mostra marker SHORT")

// --- Stable filter
excludeStable=input.bool(true,"Escludi STABLECOINS (base asset)")
f_ends(s,sfx)=>
    ls=str.length(s)
    lf=str.length(sfx)
    lf<=ls and str.substring(s,ls-lf,ls)==sfx
f_clean(sym)=>
    _s=sym
    _s:=str.replace_all(_s,".P","")
    _s:=str.replace_all(_s,"PERP","")
    _s:=str.replace_all(_s,"-","")
    _s
f_base(sym)=>
    _s=f_clean(sym)
    if f_ends(_s,"USDT")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USDC")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"BUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"FDUSD")
        str.substring(_s,0,str.length(_s)-5)
    else if f_ends(_s,"TUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USDP")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"DAI")
        str.substring(_s,0,str.length(_s)-3)
    else if f_ends(_s,"FRAX")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"SUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USDE")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"PYUSD")
        str.substring(_s,0,str.length(_s)-5)
    else if f_ends(_s,"GUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"LUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"EURS")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"EURT")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USD")
        str.substring(_s,0,str.length(_s)-3)
    else if f_ends(_s,"EUR")
        str.substring(_s,0,str.length(_s)-3)
    else
        _s
baseSym=f_base(syminfo.ticker)
isStableBase=false
if baseSym=="USDT" or baseSym=="USDC" or baseSym=="DAI" or baseSym=="TUSD" or baseSym=="BUSD" or baseSym=="FDUSD" or baseSym=="PYUSD" or baseSym=="GUSD" or baseSym=="LUSD" or baseSym=="FRAX" or baseSym=="SUSD" or baseSym=="USDP" or baseSym=="USDE" or baseSym=="EURS" or baseSym=="EURT" or baseSym=="UST" or baseSym=="USTC"
    isStableBase:=true
okAsset=true
if excludeStable and isStableBase
    okAsset:=false
showShortOK=false
if showShort and okAsset
    showShortOK:=true

showLongLines=input.bool(false,"Mostra linee LONG (Entry/SL/TP1)")

// --- Kumo thickness params
th_pct=input.float(1.0,"Soglia Kumo Thin (% prezzo)",step=0.1)
useATR=input.bool(true,"Usa normalizzazione su ATR per thinness")
atrLen=input.int(20,"ATR len (thinness/ATR%)",minval=1)
th_atrMul=input.float(0.5,"Soglia Kumo Thin (x ATR)",step=0.1)

// --- Flatness params
flatLen=input.int(10,"Lunghezza flatness (bar)",minval=2)
flatMode=input.string("range","Metodo flatness",options=["range","slope","equal"])
flatTolPct=input.float(0.20,"Tolleranza % su span",step=0.01)
flatTolAtrMul=input.float(0.05,"Tolleranza x ATR",step=0.01)

// --- Trend / Momentum filters
requireTK=input.bool(true,"Richiedi Tenkan > Kijun")
requireChikou=input.bool(true,"Richiedi Chikou libera (> high[26])")
useRVOL=input.bool(false,"Richiedi RVOL minimo")
rvolLen=input.int(20,"RVOL lookback",minval=5)
rvolMin=input.float(1.5,"RVOL minimo",step=0.1)
emaFastLen=input.int(50,"EMA fast (trend)",minval=1)
emaSlowLen=input.int(200,"EMA slow (trend)",minval=1)

// --- ATR% trading window
atrMin=input.float(0.8,"ATR% minimo",step=0.1)
atrMax=input.float(12.0,"ATR% massimo",step=0.1)

// --- Visual
showBackgrounds=input.bool(true,"Evidenziazioni di sfondo")
showAfterSignal=input.bool(false,"Mostra SL/TP solo dopo segnale")

// === Ichimoku baseline calcs
tenkan=(ta.highest(high,convLen)+ta.lowest(low,convLen))/2.0
kijun=(ta.highest(high,baseLen)+ta.lowest(low,baseLen))/2.0
spanA=(tenkan+kijun)/2.0
spanB=(ta.highest(high,spanBLen)+ta.lowest(low,spanBLen))/2.0
upperKumo=math.max(spanA,spanB)
lowerKumo=math.min(spanA,spanB)

// === Kumo thickness
kumo_dist=math.abs(spanA-spanB)
kumo_pct_price=kumo_dist/close*100.0
atr=ta.atr(atrLen)
atrPct=atr/close*100.0
kumo_atr_ratio=useATR?(kumo_dist/atr):na
thin_by_pct=kumo_pct_price<=th_pct
thin_by_atr=useATR?(kumo_atr_ratio<=th_atrMul):false
is_thin=useATR?(thin_by_pct and thin_by_atr):thin_by_pct

// --- Flatness robusta
f_tolAbs(src)=>basis=math.max(math.abs(src),syminfo.mintick),tolPct=basis*(flatTolPct/100.0),tolAtr=ta.atr(atrLen)*flatTolAtrMul,math.max(syminfo.mintick,math.max(tolPct,tolAtr))
f_flat_range(src,len)=>hi=ta.highest(src,len),lo=ta.lowest(src,len),(hi-lo)<=f_tolAbs(src)
f_flat_slope(src,len)=>avgDelta=ta.sma(math.abs(src-src[1]),len),avgDelta<=f_tolAbs(src)
f_flat_equal(src,len)=>eq=math.abs(src-src[1])<=f_tolAbs(src),ta.barssince(not eq)>=len-1
f_isFlat_any(src,len)=>flatMode=="range"?f_flat_range(src,len):flatMode=="slope"?f_flat_slope(src,len):f_flat_equal(src,len)
is_flat_ssb=f_isFlat_any(spanB,flatLen)
is_flat_ssa=f_isFlat_any(spanA,flatLen)
is_flat_any=is_flat_ssb or is_flat_ssa

// === Trend / RVOL / Chikou
emaFast=ta.ema(close,emaFastLen)
emaSlow=ta.ema(close,emaSlowLen)
slope200=emaSlow-emaSlow[1]
trendOK=close>emaFast and slope200>=0
rvol=volume/ta.sma(volume,rvolLen)
chikou_free=close>high[26]
tk_ok=not requireTK or (tenkan>kijun)
chi_ok=not requireChikou or chikou_free
rvol_ok=not useRVOL or (rvol>=rvolMin)

// === ATR% window
atr_ok=atrPct>=atrMin and atrPct<=atrMax
atr_warn=(atrPct>=atrMin*0.95 and atrPct<atrMin) or (atrPct<=atrMax*1.05 and atrPct>atrMax)

// === Pre-setup (compressione) e trigger
in_kumo=close<=upperKumo and close>=lowerKumo
pre_setup=is_thin and is_flat_any and in_kumo and trendOK
cross_up_kumo=ta.crossover(close,upperKumo)

// === Livelli dinamici breakout
winLen=input.int(48,"Finestra swing per livelli",minval=5)
volMult=input.float(1.2,"Min Volume × SMA20 per trigger",step=0.1)
useFiltersShort=input.bool(true,"Short richiede filtri trend/ATR/RVOL")
barsDelay=input.int(1,"Escludi barre recenti dal calcolo livelli",minval=1)
volOK=volume>=ta.sma(volume,20)*volMult
resLevel=ta.highest(high,winLen)[barsDelay]
supLevel=ta.lowest(low,winLen)[barsDelay]

// === Condizioni ingresso
breakout_long=false
breakdown_short_aggr=false
if okAsset
    breakout_long:=close>resLevel and cross_up_kumo and trendOK and atr_ok and tk_ok and chi_ok and rvol_ok and volOK
    breakdown_short_aggr:=close<supLevel and (useFiltersShort?(atr_ok and volOK):true)
else
    breakout_long:=false
    breakdown_short_aggr:=false

// === Stato ARMED
armed_ready=false
if pre_setup
    condTK=(not requireTK) or tk_ok
    condChi=(not requireChikou) or chi_ok
    condRV=(not useRVOL) or rvol_ok
    if trendOK and atr_ok and condTK and condChi and condRV
        if not breakout_long
            armed_ready:=true
        else
            armed_ready:=false
    else
        armed_ready:=false
else
    armed_ready:=false

// --- Stop Loss / TP1
slLongATR=input.float(1.0,"SL Long: ATR multiplo",step=0.1,minval=0.1)
slShortATR=input.float(1.0,"SL Short: ATR multiplo",step=0.1,minval=0.1)
slLong=resLevel-atr*slLongATR
slShort=supLevel+atr*slShortATR
tpLongATR=input.float(1.5,"TP1 Long: ATR multiplo",step=0.1,minval=0.1)
tpShortATR=input.float(1.5,"TP1 Short: ATR multiplo",step=0.1,minval=0.1)
tpLong=resLevel+atr*tpLongATR
tpShort=supLevel-atr*tpShortATR
rrLong=(tpLong-resLevel)/(resLevel-slLong)
rrShort=(supLevel-tpShort)/(slShort-supLevel)

// === Plot livelli
plot(resLevel,"Entry Long",color=color.new(color.lime,0),linewidth=2,style=plot.style_linebr)
plot(showShortOK?supLevel:na,"Entry Short",color=color.new(color.red,0),linewidth=2,style=plot.style_linebr)
plot(showAfterSignal?(breakout_long?slLong:na):slLong,"SL Long",color=color.new(color.white,100),linewidth=2,style=plot.style_linebr)
plot(showShortOK?(showAfterSignal?(breakdown_short_aggr?slShort:na):slShort):na,"SL Short",color=color.new(color.red,60),linewidth=2,style=plot.style_linebr)
plot(showAfterSignal?(breakout_long?tpLong:na):tpLong,"TP1 Long",color=color.new(color.white,100),linewidth=2,style=plot.style_linebr)
plot(showShortOK?(showAfterSignal?(breakdown_short_aggr?tpShort:na):tpShort):na,"TP1 Short",color=color.new(color.red,0),linewidth=2,style=plot.style_linebr)

// === Marker
plotshape(okAsset and breakout_long,title="BREAKOUT LONG",style=shape.triangleup,location=location.belowbar,size=size.large,color=color.new(color.lime,0),text="LONG")
plotshape(showShortOK and breakdown_short_aggr and okAsset,title="BREAKDOWN SHORT",style=shape.triangledown,location=location.abovebar,size=size.large,color=color.new(color.red,0),text="SHORT")

// === PRE-SETUP sticky
psHoldBars=input.int(10,"PRESETUP: hold (bar)",minval=1,maxval=50)
invOppKumo=input.bool(false,"Invalidante: close < lowerKumo")
invTrendKO=input.bool(false,"Invalidante: Trend EMA KO")
invATRhard=input.bool(false,"Invalidante: ATR% fuori (±5%)")
invThinFlatLost=input.bool(false,"Invalidante: persi sia THIN che FLAT")

invalid_hard=false
if invOppKumo and close<lowerKumo
    invalid_hard:=true
else if invTrendKO and not trendOK
    invalid_hard:=true
else if invATRhard and (atrPct<atrMin*0.95 or atrPct>atrMax*1.05)
    invalid_hard:=true
else if invThinFlatLost
    if not is_thin and not is_flat_any
        invalid_hard:=true
    else
        invalid_hard:=invalid_hard
else
    invalid_hard:=invalid_hard

var bool ps_active=false
var int ps_expire=na
var int ps_start=na
if not ps_active
    if okAsset and pre_setup
        ps_active:=true
        ps_expire:=bar_index+psHoldBars
        ps_start:=bar_index
else
    if invalid_hard
        ps_active:=false
        ps_expire:=na
        ps_start:=na
    else
        if bar_index>ps_expire
            ps_active:=false
            ps_expire:=na
            ps_start:=na

var int ps_ttl=na
if ps_active
    _ttl=ps_expire-bar_index
    if _ttl<0
        ps_ttl:=0
    else
        ps_ttl:=_ttl
else
    ps_ttl:=na

enablePSAlerts=input.bool(true,"Alert: PRE-SETUP sticky (enter/exit)")
var bool ps_prev=false
ps_enter=false
ps_exit=false
if ps_active and not ps_prev
    ps_enter:=true
else
    ps_enter:=false
if not ps_active and ps_prev
    ps_exit:=true
else
    ps_exit:=false
ps_prev:=ps_active
alertcondition(enablePSAlerts and ps_enter,title="PRE-SETUP ACTIVE",message="Presetup sticky attivo. {{ticker}} @ {{interval}}")
alertcondition(enablePSAlerts and ps_exit,title="PRE-SETUP EXPIRED",message="Presetup sticky terminato (invalidazione/timeout). {{ticker}} @ {{interval}}")

// ====== Breakout Channels (minimal, per BG canale) ======
bool strong  = input.bool(true,"Strong closes (>50% body fuori)")
int  normLen = input.int(100,"Normalization length",minval=1)
int  lenBox  = input.int(14,"Box detection len",minval=1)
int  minDur  = input.int(10,"Min durata canale",minval=1)

float lowestLow   = ta.lowest(low,normLen)
float highestHigh = ta.highest(high,normLen)
float priceRange  = highestHigh-lowestLow
float norm        = 0.0
if priceRange!=0.0
    norm:=(close-lowestLow)/priceRange
else
    norm:=0.0

float vol    = ta.stdev(norm,14)
float upper  = (ta.highestbars(vol,lenBox+1)+lenBox)/lenBox
float lower  = (ta.lowestbars(vol,lenBox+1)+lenBox)/lenBox

int   duration = math.max(nz(ta.barssince(ta.crossover(lower,upper))),1)
float h        = ta.highest(high,duration)
float l        = ta.lowest(low,duration)

var bool  bc_active=false
var float bc_top=na
var float bc_bot=na
var int   bc_start=na

if ta.crossover(upper,lower)
    if duration>minDur
        bc_active:=true
        bc_top:=h
        bc_bot:=l
        bc_start:=bar_index-duration   // <<< salva left
    else
        bc_active:=bc_active
else
    bc_active:=bc_active

float refPrice=strong?math.avg(close,open):close
if bc_active
    if refPrice>bc_top or refPrice<bc_bot
        bc_active:=false
        bc_start:=na                 // <<< reset left
    else
        if refPrice<bc_bot
            bc_active:=false
            bc_start:=na             // <<< reset left
        else
            bc_active:=bc_active
else
    bc_active:=bc_active



// ====== BBWP minimal (solo intensità PRE) ======
length   = input.int(9,"BBWP Length",minval=5)
lookback = input.int(120,"Percentile Lookback",minval=50)
lowTh    = input.float(5.0,"Low Threshold (%)")
trigger  = input.float(15.0,"Trigger Threshold (%)")

f_bbwp(src,_len,_lb)=>
    [basis,up_,lo_]=ta.bb(src,_len,2.0)
    float denom=basis
    if denom==0.0
        denom:=1e-10
    else
        denom:=denom
    float w=((up_-lo_)/denom)*100.0
    int maxLag=math.min(_lb-1,bar_index)
    float count=0.0
    float valid=0.0
    for i=0 to maxLag
        if not na(w[i])
            valid+=1.0
            if w>=w[i]
                count+=1.0
            else
                count+=0.0
        else
            valid:=valid
    float perc=na
    if valid>0.0
        perc:=(count/valid)*100.0
    else
        perc:=na
    perc

bbwp=f_bbwp(close,length,lookback)

bool isPreBreak=false
if ta.crossover(bbwp,lowTh)
    isPreBreak:=true
else
    if not na(bbwp)
        if bbwp>lowTh and bbwp<trigger
            if ta.rising(bbwp,2)
                isPreBreak:=true
            else
                isPreBreak:=false
        else
            isPreBreak:=false
    else
        isPreBreak:=false





// === Directional Bias (Long vs Short)
biasLookback=input.int(12,"Bias: lookback momentum",minval=2)
bool chikou_free_dn=close<low[26]
bool trendDown=close<emaFast and slope200<=0

float posLong=0.0, posShort=0.0
if close>upperKumo
    posLong:=1.0
    posShort:=0.0
else
    if close<lowerKumo
        posLong:=0.0
        posShort:=1.0
    else
        posLong:=0.5
        posShort:=0.5

float skew=na
if bc_active
    float den=bc_top-bc_bot
    if not na(den) and den!=0.0
        float rp=strong?math.avg(close,open):close
        skew:=(rp-bc_bot)/den
        if skew<0
            skew:=0
        else
            if skew>1
                skew:=1
            else
                skew:=skew
    else
        skew:=na
else
    skew:=na

float dUp=na
float dDn=na
if not na(resLevel) and not na(supLevel)
    dUp:=math.max(resLevel-close,0)
    dDn:=math.max(close-supLevel,0)
else
    dUp:=na
    dDn:=na

bool nearUp=false, nearDn=false
if not na(dUp) and not na(dDn)
    if dUp<dDn
        nearUp:=true
        nearDn:=false
    else
        nearUp:=false
        nearDn:=true
else
    nearUp:=false
    nearDn:=false

float mom=close-close[biasLookback]
bool upBody=close>open
bool dnBody=close<open
bool cloudUp=spanA>spanB
bool cloudDn=spanA<spanB

int W_trend=3, W_kumo=2, W_tk=2, W_chi=2, W_cloud=2, W_skew=3, W_near=2, W_mom=2, W_body=1

float longScore=0
if trendOK
    longScore+=W_trend
if posLong>0.5
    longScore+=W_kumo
else
    if posLong==0.5
        longScore+=W_kumo*0.5
if tk_ok
    longScore+=W_tk
if chi_ok
    longScore+=W_chi
if cloudUp
    longScore+=W_cloud
if not na(skew) and skew>0.6
    longScore+=W_skew
if nearUp
    longScore+=W_near
if mom>0
    longScore+=W_mom
if upBody
    longScore+=W_body

float shortScore=0
if showShortOK
    if trendDown
        shortScore+=W_trend
    if posShort>0.5
        shortScore+=W_kumo
    else
        if posShort==0.5
            shortScore+=W_kumo*0.5
    if (not requireTK and not tk_ok) or (tenkan<kijun)
        shortScore+=W_tk
    if close<low[26]
        shortScore+=W_chi
    if cloudDn
        shortScore+=W_cloud
    if not na(skew) and skew<0.4
        shortScore+=W_skew
    if nearDn
        shortScore+=W_near
    if mom<0
        shortScore+=W_mom
    if dnBody
        shortScore+=W_body


bool isShort = shortScore > longScore
bool isLong = longScore > shortScore



float denomBias=longScore+shortScore
float biasLong=na
float biasShort=na
if denomBias>0
    biasLong:=(longScore/denomBias)*100.0
    biasShort:=(shortScore/denomBias)*100.0

// === BG in base al BIAS (gradiente)
bg_useBias   = input.bool(true,"BG: usa gradiente bias")
bg_bullCol   = input.color(color.new(color.lime,0),"BG: colore bull")
bg_bearCol   = input.color(color.new(color.red ,0),"BG: colore bear")
bg_boostBias = input.int(20,"BG: boost opacità con |bias|",minval=0,maxval=100)

wEMA=input.float(1.0,"Peso bias EMA",minval=0)
wChikou=input.float(0.6,"Peso bias Chikou",minval=0)
wKumo=input.float(0.8,"Peso bias Kumo",minval=0)
wChannel=input.float(0.6,"Peso bias Canale",minval=0)

float biasEMA=(close>emaFast?0.5:-0.5)+(slope200>0?0.5:-0.5)
float chikUp=na(high[26])?0.0:(close>high[26]?1.0:0.0)
float chikDn=na(low[26])?0.0:(close<low[26]?1.0:0.0)
float biasChi=chikUp-chikDn
float denomK=math.max(upperKumo-lowerKumo,syminfo.mintick)
float biasKu=in_kumo?((close-lowerKumo)/denomK)*2.0-1.0:(close>upperKumo?1.0:-1.0)
float biasChn=0.0
if bc_active
    float denomC=math.max(bc_top-bc_bot,syminfo.mintick)
    biasChn:=((close-bc_bot)/denomC)*2.0-1.0
float wSum=math.max(wEMA+wChikou+wKumo+wChannel,1e-6)
float bias=(wEMA*biasEMA+wChikou*biasChi+wKumo*biasKu+wChannel*biasChn)/wSum
bias:=math.max(-1.0,math.min(1.0,bias))

// ---- BG unificato
showUnifiedBG = input.bool(true,"BG unificato: Canale→BBWP→PRE")
bcTranspBase  = input.int(88,"BG Canale: base (0-100)",minval=0,maxval=100)
bcBoostBBWP   = input.int(30,"Boost con BBWP",minval=0,maxval=100)
bcBoostPRE    = input.int(28,"Boost con PRESETUP",minval=0,maxval=100)

color bgFinal = na
if showUnifiedBG
    if okAsset and breakout_long
        bgFinal:=color.new(color.red,86)
    else
        bool chan=bc_active
        if chan
            int t=bcTranspBase
            if isPreBreak
                t:=bcTranspBase-bcBoostBBWP
            if pre_setup or ps_active
                t:=t-bcBoostPRE
            if bg_useBias
                t:=t-int(math.abs(bias)*bg_boostBias)
            t:=math.max(0,math.min(100,t))
            color grad=bg_useBias?color.from_gradient(bias,-1,1,bg_bearCol,bg_bullCol):color.fuchsia
            bgFinal:=color.new(grad,t)
        else
            if pre_setup or ps_active
                int t2=95-int(math.abs(bias)*(bg_useBias?bg_boostBias/2:0))
                t2:=math.max(0,math.min(100,t2))
                color grad2=bg_useBias?color.from_gradient(bias,-1,1,bg_bearCol,bg_bullCol):color.fuchsia
                bgFinal:=color.new(grad2,t2)
            else if isPreBreak
                int t3=60-int(math.abs(bias)*(bg_useBias?bg_boostBias/3:0))
                t3:=math.max(0,math.min(100,t3))
                color grad3=bg_useBias?color.from_gradient(bias,-1,1,bg_bearCol,bg_bullCol):color.orange
                bgFinal:=color.new(grad3,t3)
            else
                bgFinal:=na
else
    bgFinal:=na
bgcolor(bgFinal)

// === Alerts
alertcondition(okAsset and breakout_long,title="BREAKOUT LONG",message="Breakout long confermato.")
alertcondition(showShortOK and okAsset and breakdown_short_aggr,title="BREAKDOWN SHORT",message="Breakdown short aggressivo.")
tp1_long_hit=high>=tpLong
tp1_short_hit=low<=tpShort
alertcondition(okAsset and tp1_long_hit,title="TP1 LONG HIT",message="TP1 Long raggiunto.")
alertcondition(showShortOK and okAsset and tp1_short_hit,title="TP1 SHORT HIT",message="TP1 Short raggiunto.")





alertcondition(enablePSAlerts and ps_enter and isLong,title="PRE LONG",message="Presetup sticky attivo. {{ticker}} @ {{interval}}")
alertcondition(enablePSAlerts and ps_enter and isShort,title="PRE SHORT",message="Presetup sticky attivo. {{ticker}} @ {{interval}}")


// === ATR FLOATING BLOCK (semplice) ===
// mostriamo un blocco fluttuante dell'altezza dell'atr.

atrBlkOn       = input.bool(true,  "ATR Block: attivo")
atrBlkMul      = input.float(1.2,  "ATR Block × ATR", minval=0.1, step=0.1)
atrBlkTransp   = input.int(65,     "ATR Block trasparenza", minval=0, maxval=100)
atrBlkMinTicks = input.int(8,      "ATR Block altezza minima (ticks)", minval=1)
atrBlkBiasCol  = input.bool(true,  "ATR Block: colore in base al bias")

var box atrBlock = na

if atrBlkOn and bc_active and not na(bc_start) and not na(bc_top) and not na(bc_bot)
    mid   = (bc_top + bc_bot) / 2.0
    hRaw  = atr * atrBlkMul
    hMin  = syminfo.mintick * atrBlkMinTicks
    h     = math.max(hRaw, hMin)
    topY  = mid + h/2.0
    botY  = mid - h/2.0
    col0  = atrBlkBiasCol ? color.from_gradient(bias, -1, 1, bg_bearCol, bg_bullCol) : color.fuchsia
    colBg = color.new(col0, atrBlkTransp)
    colBr = color.new(col0, math.min(100, atrBlkTransp + 20))
    if na(atrBlock)
        atrBlock := box.new(bc_start, topY, bar_index, botY, bgcolor=colBg, border_color=colBr)
    else
        box.set_left(atrBlock,  bc_start)
        box.set_right(atrBlock, bar_index)
        box.set_top(atrBlock,   topY)
        box.set_bottom(atrBlock,botY)
        box.set_bgcolor(atrBlock,colBg)
        box.set_border_color(atrBlock,colBr)
else
    if not na(atrBlock)
        box.delete(atrBlock)
        atrBlock := na
// === fine ATR FLOATING BLOCK ===
