//@version=5
indicator("KumoSAN", overlay=true)

// --- Ichimoku lengths
convLen=input.int(9,"Tenkan",minval=1)
baseLen=input.int(26,"Kijun",minval=1)
spanBLen=input.int(52,"Senkou B",minval=1)

// --- Visual SHORT
showShort=input.bool(false,"Attiva sezione SHORT")
showShortMarker=input.bool(false,"Mostra marker SHORT")

// --- Stable filter
excludeStable=input.bool(true,"Escludi STABLECOINS (base asset)")
f_ends(s,sfx)=>
    ls=str.length(s)
    lf=str.length(sfx)
    lf<=ls and str.substring(s,ls-lf,ls)==sfx
f_clean(sym)=>
    _s=sym
    _s:=str.replace_all(_s,".P","")
    _s:=str.replace_all(_s,"PERP","")
    _s:=str.replace_all(_s,"-","")
    _s
f_base(sym)=>
    _s=f_clean(sym)
    if f_ends(_s,"USDT")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USDC")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"BUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"FDUSD")
        str.substring(_s,0,str.length(_s)-5)
    else if f_ends(_s,"TUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USDP")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"DAI")
        str.substring(_s,0,str.length(_s)-3)
    else if f_ends(_s,"FRAX")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"SUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USDE")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"PYUSD")
        str.substring(_s,0,str.length(_s)-5)
    else if f_ends(_s,"GUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"LUSD")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"EURS")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"EURT")
        str.substring(_s,0,str.length(_s)-4)
    else if f_ends(_s,"USD")
        str.substring(_s,0,str.length(_s)-3)
    else if f_ends(_s,"EUR")
        str.substring(_s,0,str.length(_s)-3)
    else
        _s
baseSym=f_base(syminfo.ticker)
isStableBase=false
if baseSym=="USDT" or baseSym=="USDC" or baseSym=="DAI" or baseSym=="TUSD" or baseSym=="BUSD" or baseSym=="FDUSD" or baseSym=="PYUSD" or baseSym=="GUSD" or baseSym=="LUSD" or baseSym=="FRAX" or baseSym=="SUSD" or baseSym=="USDP" or baseSym=="USDE" or baseSym=="EURS" or baseSym=="EURT" or baseSym=="UST" or baseSym=="USTC"
    isStableBase:=true
okAsset=true
if excludeStable and isStableBase
    okAsset:=false
showShortOK=false
if showShort and okAsset
    showShortOK:=true

showLongLines=input.bool(false,"Mostra linee LONG (Entry/SL/TP1)")

// --- Kumo thickness params
th_pct=input.float(1.0,"Soglia Kumo Thin (% prezzo)",step=0.1)
useATR=input.bool(true,"Usa normalizzazione su ATR per thinness")
atrLen=input.int(20,"ATR len (thinness/ATR%)",minval=1)
th_atrMul=input.float(0.5,"Soglia Kumo Thin (x ATR)",step=0.1)

// --- Flatness params
flatLen=input.int(10,"Lunghezza flatness (bar)",minval=2)
flatMode=input.string("range","Metodo flatness",options=["range","slope","equal"])
flatTolPct=input.float(0.20,"Tolleranza % su span",step=0.01)
flatTolAtrMul=input.float(0.05,"Tolleranza x ATR",step=0.01)

// --- Trend / Momentum filters
requireTK=input.bool(true,"Richiedi Tenkan > Kijun")
requireChikou=input.bool(true,"Richiedi Chikou libera (> high[26])")
useRVOL=input.bool(false,"Richiedi RVOL minimo")
rvolLen=input.int(20,"RVOL lookback",minval=5)
rvolMin=input.float(1.5,"RVOL minimo",step=0.1)
emaFastLen=input.int(50,"EMA fast (trend)",minval=1)
emaSlowLen=input.int(200,"EMA slow (trend)",minval=1)

// --- ATR% trading window
atrMin=input.float(0.8,"ATR% minimo",step=0.1)
atrMax=input.float(12.0,"ATR% massimo",step=0.1)

// --- Visual
showBackgrounds=input.bool(true,"Evidenziazioni di sfondo")
showAfterSignal=input.bool(false,"Mostra SL/TP solo dopo segnale")

// === Ichimoku baseline calcs
tenkan=(ta.highest(high,convLen)+ta.lowest(low,convLen))/2.0
kijun=(ta.highest(high,baseLen)+ta.lowest(low,baseLen))/2.0
spanA=(tenkan+kijun)/2.0
spanB=(ta.highest(high,spanBLen)+ta.lowest(low,spanBLen))/2.0
upperKumo=math.max(spanA,spanB)
lowerKumo=math.min(spanA,spanB)

// === Kumo thickness
kumo_dist=math.abs(spanA-spanB)
kumo_pct_price=kumo_dist/close*100.0
atr=ta.atr(atrLen)
atrPct=atr/close*100.0
kumo_atr_ratio=useATR?(kumo_dist/atr):na
thin_by_pct=kumo_pct_price<=th_pct
thin_by_atr=useATR?(kumo_atr_ratio<=th_atrMul):false
is_thin=useATR?(thin_by_pct and thin_by_atr):thin_by_pct

// --- Flatness robusta
f_tolAbs(src)=>basis=math.max(math.abs(src),syminfo.mintick),tolPct=basis*(flatTolPct/100.0),tolAtr=ta.atr(atrLen)*flatTolAtrMul,math.max(syminfo.mintick,math.max(tolPct,tolAtr))
f_flat_range(src,len)=>hi=ta.highest(src,len),lo=ta.lowest(src,len),(hi-lo)<=f_tolAbs(src)
f_flat_slope(src,len)=>avgDelta=ta.sma(math.abs(src-src[1]),len),avgDelta<=f_tolAbs(src)
f_flat_equal(src,len)=>eq=math.abs(src-src[1])<=f_tolAbs(src),ta.barssince(not eq)>=len-1
f_isFlat_any(src,len)=>flatMode=="range"?f_flat_range(src,len):flatMode=="slope"?f_flat_slope(src,len):f_flat_equal(src,len)
is_flat_ssb=f_isFlat_any(spanB,flatLen)
is_flat_ssa=f_isFlat_any(spanA,flatLen)
is_flat_any=is_flat_ssb or is_flat_ssa

// === Trend / RVOL / Chikou
emaFast=ta.ema(close,emaFastLen)
emaSlow=ta.ema(close,emaSlowLen)
slope200=emaSlow-emaSlow[1]
trendOK=close>emaFast and slope200>=0
rvol=volume/ta.sma(volume,rvolLen)
chikou_free=close>high[26]
tk_ok=not requireTK or (tenkan>kijun)
chi_ok=not requireChikou or chikou_free
rvol_ok=not useRVOL or (rvol>=rvolMin)

// === ATR% window
atr_ok=atrPct>=atrMin and atrPct<=atrMax
atr_warn=(atrPct>=atrMin*0.95 and atrPct<atrMin) or (atrPct<=atrMax*1.05 and atrPct>atrMax)

// === Pre-setup (compressione) e trigger
in_kumo=close<=upperKumo and close>=lowerKumo
pre_setup=is_thin and is_flat_any and in_kumo and trendOK
cross_up_kumo=ta.crossover(close,upperKumo)

// === Livelli dinamici breakout
winLen=input.int(48,"Finestra swing per livelli",minval=5)
volMult=input.float(1.2,"Min Volume × SMA20 per trigger",step=0.1)
useFiltersShort=input.bool(true,"Short richiede filtri trend/ATR/RVOL")
barsDelay=input.int(1,"Escludi barre recenti dal calcolo livelli",minval=1)
volOK=volume>=ta.sma(volume,20)*volMult
resLevel=ta.highest(high,winLen)[barsDelay]
supLevel=ta.lowest(low,winLen)[barsDelay]

// === Condizioni ingresso (con gating okAsset via if/else)
breakout_long=false
breakdown_short_aggr=false
if okAsset
    breakout_long:=close>resLevel and cross_up_kumo and trendOK and atr_ok and tk_ok and chi_ok and rvol_ok and volOK
    breakdown_short_aggr:=close<supLevel and (useFiltersShort?(atr_ok and volOK):true)
else
    breakout_long:=false
    breakdown_short_aggr:=false

// === Stato ARMED
armed_ready=false
if pre_setup
    condTK=(not requireTK) or tk_ok
    condChi=(not requireChikou) or chi_ok
    condRV=(not useRVOL) or rvol_ok
    if trendOK and atr_ok and condTK and condChi and condRV
        if not breakout_long
            armed_ready:=true
        else
            armed_ready:=false
    else
        armed_ready:=false
else
    armed_ready:=false

// --- Stop Loss proposti
slLongATR=input.float(1.0,"SL Long: ATR multiplo",step=0.1,minval=0.1)
slShortATR=input.float(1.0,"SL Short: ATR multiplo",step=0.1,minval=0.1)
slLong=resLevel-atr*slLongATR
slShort=supLevel+atr*slShortATR

// --- Take Profit 1
tpLongATR=input.float(1.5,"TP1 Long: ATR multiplo",step=0.1,minval=0.1)
tpShortATR=input.float(1.5,"TP1 Short: ATR multiplo",step=0.1,minval=0.1)
tpLong=resLevel+atr*tpLongATR
tpShort=supLevel-atr*tpShortATR

// --- Risk/Reward su TP1
rrLong=(tpLong-resLevel)/(resLevel-slLong)
rrShort=(supLevel-tpShort)/(slShort-supLevel)

// === Plot livelli (Long visibili, altri nascosti se vuoi pulizia)
plot(resLevel,"Entry Long",color=color.new(color.lime,0),linewidth=2,style=plot.style_linebr)
plot(showShortOK?supLevel:na,"Entry Short",color=color.new(color.red,0),linewidth=2,style=plot.style_linebr)
plot(showAfterSignal?(breakout_long?slLong:na):slLong,"SL Long",color=color.new(color.white,100),linewidth=2,style=plot.style_linebr)
plot(showShortOK?(showAfterSignal?(breakdown_short_aggr?slShort:na):slShort):na,"SL Short",color=color.new(color.red,60),linewidth=2,style=plot.style_linebr)
plot(showAfterSignal?(breakout_long?tpLong:na):tpLong,"TP1 Long",color=color.new(color.white,100),linewidth=2,style=plot.style_linebr)
plot(showShortOK?(showAfterSignal?(breakdown_short_aggr?tpShort:na):tpShort):na,"TP1 Short",color=color.new(color.red,0),linewidth=2,style=plot.style_linebr)

// === Marker segnali
plotshape(okAsset and breakout_long,title="BREAKOUT LONG",style=shape.triangleup,location=location.belowbar,size=size.large,color=color.new(color.lime,0),text="LONG")
plotshape(showShortOK and breakdown_short_aggr and okAsset,title="BREAKDOWN SHORT",style=shape.triangledown,location=location.abovebar,size=size.large,color=color.new(color.red,0),text="SHORT")

// === PRE-SETUP sticky: durata e invalidazioni
psHoldBars=input.int(5,"PRESETUP: hold (bar)",minval=1,maxval=50)
invOppKumo=input.bool(false,"Invalidante: close < lowerKumo")
invTrendKO=input.bool(false,"Invalidante: Trend EMA KO")
invATRhard=input.bool(false,"Invalidante: ATR% fuori (±5%)")
invThinFlatLost=input.bool(false,"Invalidante: persi sia THIN che FLAT")

invalid_hard=false
if invOppKumo and close<lowerKumo
    invalid_hard:=true
else if invTrendKO and not trendOK
    invalid_hard:=true
else if invATRhard and (atrPct<atrMin*0.95 or atrPct>atrMax*1.05)
    invalid_hard:=true
else if invThinFlatLost
    if not is_thin and not is_flat_any
        invalid_hard:=true
    else
        invalid_hard:=invalid_hard
else
    invalid_hard:=invalid_hard

var bool ps_active=false
var int ps_expire=na
var int ps_start=na

if not ps_active
    if okAsset and pre_setup
        ps_active:=true
        ps_expire:=bar_index+psHoldBars
        ps_start:=bar_index
else
    if invalid_hard
        ps_active:=false
        ps_expire:=na
        ps_start:=na
    else
        if bar_index>ps_expire
            ps_active:=false
            ps_expire:=na
            ps_start:=na

// TTL robusto (niente riassegnazione duplicata)
var int ps_ttl=na
if ps_active
    _ttl=ps_expire-bar_index
    if _ttl<0
        ps_ttl:=0
    else
        ps_ttl:=_ttl
else
    ps_ttl:=na

// Alert opzionali sticky
enablePSAlerts=input.bool(true,"Alert: PRE-SETUP sticky (enter/exit)")
var bool ps_prev=false
ps_enter=false
ps_exit=false
if ps_active and not ps_prev
    ps_enter:=true
else
    ps_enter:=false
if not ps_active and ps_prev
    ps_exit:=true
else
    ps_exit:=false
ps_prev:=ps_active
alertcondition(enablePSAlerts and ps_enter,title="PRE-SETUP ACTIVE",message="Presetup sticky attivo. {{ticker}} @ {{interval}}")
alertcondition(enablePSAlerts and ps_exit,title="PRE-SETUP EXPIRED",message="Presetup sticky terminato (invalidazione/timeout). {{ticker}} @ {{interval}}")

// ====== Breakout Channels (minimal, per BG canale) ======
bool strong  = input.bool(true,  "Strong closes (>50% body fuori)")
int  normLen = input.int(100,    "Normalization length", minval=1)
int  lenBox  = input.int(14,     "Box detection len",    minval=1)
int  minDur  = input.int(10,     "Min durata canale",    minval=1)

float lowestLow   = ta.lowest(low,  normLen)
float highestHigh = ta.highest(high, normLen)
float priceRange  = highestHigh - lowestLow
float norm        = 0.0
if priceRange != 0.0
    norm := (close - lowestLow) / priceRange
else
    norm := 0.0

float vol    = ta.stdev(norm, 14)
float upper  = (ta.highestbars(vol, lenBox + 1) + lenBox) / lenBox
float lower  = (ta.lowestbars(vol,  lenBox + 1) + lenBox) / lenBox

int   duration = math.max(nz(ta.barssince(ta.crossover(lower, upper))), 1)
float h        = ta.highest(high, duration)
float l        = ta.lowest(low,  duration)

var bool  bc_active=false
var float bc_top=na
var float bc_bot=na

if ta.crossover(upper, lower)
    if duration>minDur
        bc_active:=true
        bc_top:=h
        bc_bot:=l
    else
        bc_active:=bc_active
else
    bc_active:=bc_active

float refPrice=close
if strong
    refPrice:=math.avg(close,open)
else
    refPrice:=close

if bc_active
    if refPrice>bc_top
        bc_active:=false
    else
        if refPrice<bc_bot
            bc_active:=false
        else
            bc_active:=bc_active
else
    bc_active:=bc_active

// ====== BBWP minimal (solo per intensità PRE) ======
length   = input.int(9,"BBWP Length",minval=5)
lookback = input.int(120,"Percentile Lookback",minval=50)
lowTh    = input.float(5.0,"Low Threshold (%)")
trigger  = input.float(15.0,"Trigger Threshold (%)")

f_bbwp(src,_len,_lb)=>
    [basis,up_,lo_]=ta.bb(src,_len,2.0)
    float denom=basis
    if denom==0.0
        denom:=1e-10
    else
        denom:=denom
    float w=((up_-lo_)/denom)*100.0
    int maxLag=math.min(_lb-1,bar_index)
    float count=0.0
    float valid=0.0
    for i=0 to maxLag
        if not na(w[i])
            valid+=1.0
            if w>=w[i]
                count+=1.0
            else
                count+=0.0
        else
            valid:=valid
    float perc=na
    if valid>0.0
        perc:=(count/valid)*100.0
    else
        perc:=na
    perc

bbwp=f_bbwp(close,length,lookback)

bool isPreBreak=false
if ta.crossover(bbwp,lowTh)
    isPreBreak:=true
else
    if not na(bbwp)
        if bbwp>lowTh and bbwp<trigger
            if ta.rising(bbwp,2)
                isPreBreak:=true
            else
                isPreBreak:=false
        else
            isPreBreak:=false
    else
        isPreBreak:=false

// === Directional Bias (Long vs Short)
biasLookback=input.int(12,"Bias: lookback momentum",minval=2)
bool chikou_free_dn=false
if close<low[26]
    chikou_free_dn:=true
else
    chikou_free_dn:=false

bool trendDown=false
if close<emaFast and slope200<=0
    trendDown:=true
else
    trendDown:=false

float posLong=0.0, posShort=0.0
if close>upperKumo
    posLong:=1.0
    posShort:=0.0
else
    if close<lowerKumo
        posLong:=0.0
        posShort:=1.0
    else
        posLong:=0.5
        posShort:=0.5

float skew=na
if bc_active
    float den=bc_top-bc_bot
    if not na(den) and den!=0.0
        float rp=strong?math.avg(close,open):close
        skew:=(rp-bc_bot)/den
        if skew<0
            skew:=0
        else
            if skew>1
                skew:=1
            else
                skew:=skew
    else
        skew:=na
else
    skew:=na

float dUp=na
float dDn=na

if not na(resLevel) and not na(supLevel)
    dUp:=math.max(resLevel-close,0)
    dDn:=math.max(close-supLevel,0)
else
    dUp:=na
    dDn:=na

bool nearUp=false, nearDn=false
if not na(dUp) and not na(dDn)
    if dUp<dDn
        nearUp:=true
        nearDn:=false
    else
        nearUp:=false
        nearDn:=true
else
    nearUp:=false
    nearDn:=false

float mom=close-close[biasLookback]
bool upBody=close>open
bool dnBody=close<open
bool cloudUp=spanA>spanB
bool cloudDn=spanA<spanB

int W_trend=3, W_kumo=2, W_tk=2, W_chi=2, W_cloud=2, W_skew=3, W_near=2, W_mom=2, W_body=1

float longScore=0
if trendOK
    longScore+=W_trend
else
    longScore+=0
if posLong>0.5
    longScore+=W_kumo
else
    if posLong==0.5
        longScore+=W_kumo*0.5
    else
        longScore+=0
if tk_ok
    longScore+=W_tk
else
    longScore+=0
if chi_ok
    longScore+=W_chi
else
    longScore+=0
if cloudUp
    longScore+=W_cloud
else
    longScore+=0
if not na(skew) and skew>0.6
    longScore+=W_skew
else
    longScore+=0
if nearUp
    longScore+=W_near
else
    longScore+=0
if mom>0
    longScore+=W_mom
else
    longScore+=0
if upBody
    longScore+=W_body
else
    longScore+=0

float shortScore=0
if showShortOK
    if trendDown
        shortScore+=W_trend
    else
        shortScore+=0
    if posShort>0.5
        shortScore+=W_kumo
    else
        if posShort==0.5
            shortScore+=W_kumo*0.5
        else
            shortScore+=0
    if not requireTK and not tk_ok
        shortScore+=W_tk
    else
        if tenkan<kijun
            shortScore+=W_tk
        else
            shortScore+=0
    if chikou_free_dn
        shortScore+=W_chi
    else
        shortScore+=0
    if cloudDn
        shortScore+=W_cloud
    else
        shortScore+=0
    if not na(skew) and skew<0.4
        shortScore+=W_skew
    else
        shortScore+=0
    if nearDn
        shortScore+=W_near
    else
        shortScore+=0
    if mom<0
        shortScore+=W_mom
    else
        shortScore+=0
    if dnBody
        shortScore+=W_body
    else
        shortScore+=0
else
    shortScore+=0

float denomBias=longScore+shortScore
float biasLong=na, 
float biasShort=na
if denomBias>0
    biasLong:=(longScore/denomBias)*100.0
    biasShort:=(shortScore/denomBias)*100.0
else
    biasLong:=na
    biasShort:=na

// === BG unificato: Canale→BBWP→PRE (+ opzionale boost da Bias)
showUnifiedBG=input.bool(true,"BG unificato: Canale→BBWP→PRE")
bcTranspBase=input.int(88,"BG Canale: base (0-100)",minval=0,maxval=100)
bcBoostBBWP=input.int(30,"Boost con BBWP",minval=0,maxval=100)
bcBoostPRE=input.int(28,"Boost con PRESETUP",minval=0,maxval=100)
bcBoostBias=input.int(16,"Boost con BIAS (opz.)",minval=0,maxval=100)

color bgFinal=na
if showUnifiedBG and showBackgrounds
    if okAsset and breakout_long
        bgFinal:=color.new(color.red,86)
    else
        bool chan=false
        if bc_active
            chan:=true
        else
            chan:=false
        if chan
            int t=bcTranspBase
            if isPreBreak
                t:=t-bcBoostBBWP
            else
                t:=t
            if pre_setup or ps_active
                t:=t-bcBoostPRE
            else
                t:=t
            // Boost addizionale in base alla forza direzionale (max tra Long/Short)
            if not na(biasLong) and not na(biasShort)
                float biasMax=math.max(biasLong,biasShort)
                float strength=(biasMax-50.0)/50.0
                if strength<0
                    strength:=0
                else
                    strength:=strength
                int add=int(math.round(bcBoostBias*strength))
                t:=t-add
            else
                t:=t
            if t<0
                t:=0
            else
                if t>100
                    t:=100
                else
                    t:=t
            bgFinal:=color.new(color.yellow,t)
        else
            bgFinal:=na
else
    bgFinal:=na
bgcolor(bgFinal)

// === Alerts (gated su okAsset)
alertcondition(okAsset and breakout_long,title="BREAKOUT LONG",message="Breakout long confermato.")
alertcondition(showShortOK and okAsset and breakdown_short_aggr,title="BREAKDOWN SHORT",message="Breakdown short aggressivo.")
tp1_long_hit=high>=tpLong
tp1_short_hit=low<=tpShort
alertcondition(okAsset and tp1_long_hit,title="TP1 LONG HIT",message="TP1 Long raggiunto.")
alertcondition(showShortOK and okAsset and tp1_short_hit,title="TP1 SHORT HIT",message="TP1 Short raggiunto.")

// === Tabella debug con semaforo
showTable=input.bool(true,"Mostra tabella")
tblPos=input.string("top_left","Posizione tabella",options=["top_right","top_left","bottom_right","bottom_left"])
f_pos(p)=>p=="top_right"?position.top_right:p=="top_left"?position.top_left:p=="bottom_right"?position.bottom_right:position.bottom_left
f_light(ok,warn)=>ok?color.lime:warn?color.yellow:color.red
f_colbg(ok,warn)=>ok?color.new(color.lime,0):warn?color.new(color.yellow,0):color.new(color.red,0)

var table t=na
var string _p=na
var int _rows=0
rowsCount=showShort?20:16
if barstate.isfirst or na(t) or tblPos!=_p or rowsCount!=_rows
    if not na(t)
        table.delete(t)
    t:=table.new(f_pos(tblPos),2,rowsCount,border_width=1)
    _p:=tblPos
    _rows:=rowsCount

if showTable and barstate.islast and not na(t)
    table.cell(t,0,0,"PRE-SETUP",text_color=color.white,bgcolor=f_light(ps_active,false))
    table.cell(t,1,0,ps_active?("YES (TTL "+str.tostring(ps_ttl)+")"):"NO",text_color=color.white,bgcolor=f_colbg(ps_active,false))
    table.cell(t,0,1,"IN KUMO",text_color=color.white,bgcolor=f_light(in_kumo,false))
    table.cell(t,1,1,in_kumo?"YES":"NO",text_color=color.white,bgcolor=f_colbg(in_kumo,false))
    table.cell(t,0,2,"KUMO THIN",text_color=color.white,bgcolor=f_light(is_thin,false))
    table.cell(t,1,2,str.tostring(kumo_pct_price,"#.##")+"%",text_color=color.white,bgcolor=f_colbg(is_thin,false))
    table.cell(t,0,3,"FLAT SSA/SSB",text_color=color.white,bgcolor=f_light(is_flat_any,false))
    table.cell(t,1,3,is_flat_any?"YES":"NO",text_color=color.white,bgcolor=f_colbg(is_flat_any,false))
    table.cell(t,0,4,"TREND EMA",text_color=color.white,bgcolor=f_light(trendOK,false))
    table.cell(t,1,4,trendOK?"YES":"NO",text_color=color.white,bgcolor=f_colbg(trendOK,false))
    table.cell(t,0,5,"TK>KJ",text_color=color.white,bgcolor=f_light(tk_ok,false))
    table.cell(t,1,5,tk_ok?"YES":"NO",text_color=color.white,bgcolor=f_colbg(tk_ok,false))
    table.cell(t,0,6,"CHIKOU OK",text_color=color.white,bgcolor=f_light(chi_ok,false))
    table.cell(t,1,6,chi_ok?"YES":"NO",text_color=color.white,bgcolor=f_colbg(chi_ok,false))
    table.cell(t,0,7,"RVOL",text_color=color.white,bgcolor=f_light(rvol_ok,false))
    table.cell(t,1,7,useRVOL?str.tostring(rvol,"#.##")+"x":"n/a",text_color=color.white,bgcolor=f_colbg(rvol_ok,false))
    table.cell(t,0,8,"ATR% RANGE",text_color=color.white,bgcolor=f_light(atr_ok,atr_warn))
    table.cell(t,1,8,str.tostring(atrPct,"#.##")+"%",text_color=color.white,bgcolor=f_colbg(atr_ok,atr_warn))
    table.cell(t,0,9,"ARMED",text_color=color.white,bgcolor=f_light(armed_ready,false))
    table.cell(t,1,9,armed_ready?"YES":"NO",text_color=color.white,bgcolor=f_colbg(armed_ready,false))
    table.cell(t,0,10,"ENTRY LONG",text_color=color.white,bgcolor=f_light(close>resLevel,false))
    table.cell(t,1,10,str.tostring(resLevel,"#.#####"),text_color=color.lime,bgcolor=f_colbg(close>resLevel,false))
    table.cell(t,0,11,"SL LONG",text_color=color.white,bgcolor=f_light(close>slLong,false))
    table.cell(t,1,11,str.tostring(slLong,"#.#####"),text_color=color.lime,bgcolor=f_colbg(close>slLong,false))
    table.cell(t,0,12,"TP1 LONG",text_color=color.white,bgcolor=f_light(close<tpLong,false))
    table.cell(t,1,12,str.tostring(tpLong,"#.#####"),text_color=color.lime,bgcolor=f_colbg(close<tpLong,false))
    table.cell(t,0,13,"R:R LONG",text_color=color.white,bgcolor=f_light(rrLong>1.5,rrLong>1.0))
    table.cell(t,1,13,str.tostring(rrLong,"#.##"),text_color=color.lime,bgcolor=f_colbg(rrLong>1.5,rrLong>1.0))
    if showShort
        table.cell(t,0,14,"ENTRY SHORT",text_color=color.white,bgcolor=f_light(close<supLevel,false))
        table.cell(t,1,14,str.tostring(supLevel,"#.#####"),text_color=color.red,bgcolor=f_colbg(close<supLevel,false))
        table.cell(t,0,15,"SL SHORT",text_color=color.white,bgcolor=f_light(close<slShort,false))
        table.cell(t,1,15,str.tostring(slShort,"#.#####"),text_color=color.red,bgcolor=f_colbg(close<slShort,false))
        table.cell(t,0,16,"TP1 SHORT",text_color=color.white,bgcolor=f_light(close>tpShort,false))
        table.cell(t,1,16,str.tostring(tpShort,"#.#####"),text_color=color.red,bgcolor=f_colbg(close>tpShort,false))
        table.cell(t,0,17,"R:R SHORT",text_color=color.white,bgcolor=f_light(rrShort>1.5,rrShort>1.0))
        table.cell(t,1,17,str.tostring(rrShort,"#.##"),text_color=color.red,bgcolor=f_colbg(rrShort>1.5,rrShort>1.0))
    // Bias rows
    int idxBL=na
    int idxBS=na
    if showShort
        idxBL:=18
        idxBS:=19
    else
        idxBL:=14
        idxBS:=15
    color bgLong=na
    if not na(biasLong)
        if biasLong>=60
            bgLong:=color.new(color.lime,0)
        else
            if biasLong>=40
                bgLong:=color.new(color.yellow,0)
            else
                bgLong:=color.new(color.red,0)
    else
        bgLong:=color.new(color.gray,90)
    color bgShort=na
    if not na(biasShort)
        if biasShort>=60
            bgShort:=color.new(color.lime,0)
        else
            if biasShort>=40
                bgShort:=color.new(color.yellow,0)
            else
                bgShort:=color.new(color.red,0)
    else
        bgShort:=color.new(color.gray,90)
    table.cell(t,0,idxBL,"BIAS LONG",text_color=color.white,bgcolor=bgLong)
    table.cell(t,1,idxBL,not na(biasLong)?str.tostring(biasLong,"#.0")+"%":"n/a",text_color=color.white,bgcolor=bgLong)
    table.cell(t,0,idxBS,"BIAS SHORT",text_color=color.white,bgcolor=bgShort)
    table.cell(t,1,idxBS,not na(biasShort)?str.tostring(biasShort,"#.0")+"%":"n/a",text_color=color.white,bgcolor=bgShort)
